/* Partial Application

Implement function F that allows to do 
partial function application in 
a form of: ðº(ð‘¥,ð‘¦,ð‘§ ...) = ð‘ ð¹(ð‘¥, ðº(ð‘¥,ð‘¦,ð‘§ ...)) â†’ ð»(ð‘¦,ð‘§â€¦) = ð‘ 
F should accept any number of parameters to apply.
 G may accept any number of parameters.  
*/

const enablePartialApplication = (fn) => (...args) => {
    if (args.length >= fn.length)
        return fn(...args);
    return enablePartialApplication(fn.bind(null, ...args));
};

function partialApplication(func, ...args) {
    const fun = enablePartialApplication(func);
    return fun(args);
}

function partialApplication2(func, ...args) {
    return fn.bind(null, ...args);
}

const _fn = (x, y, z) => (x * y) / z;
const fnFixedX = partialApplication(_fn, 3); // fixes x to 3: (y, z) => (3 * y) / z

//console.log(fnFixedX(2, 1));

/*Currying  

Implement function curry that allows to do currying like:
 ð‘“(ð‘¥,ð‘¦,ð‘§) = ð‘, ð‘ð‘¢ð‘Ÿð‘Ÿð‘¦(ð‘“) = ð‘¥ â†’ (ð‘¦ â†’ (ð‘§ â†’ ð‘)) 
  Function f may accept any number of explicit parameters.
   Implicit parameters are not subject to curry.  
 
*/

const enableCurry = (fn) => (arg) => {
    if (1 >= fn.length)
        return fn(arg);
    return enableCurry(fn.bind(null, arg));
};

const cfn = (x, y, z) => {
    console.log("begin");
    console.log(x);
    console.log(y);
    console.log(z);
    console.log("end");
};

/*
let  test2 = enableCurry(cfn);
let c1 = test2(1);
console.log(c1);
let c2 = c1(2);
console.log(c2);
let c3 = c2(3);
console.log(c3);
*/


/* Linear fold 
Implement linear fold function that works on arrays: F(array, callback[, initialValue]), 
callback: Function to execute on each value in the array, taking four arguments: 
previousValue: The value previously returned in the last invocation of the callback, or initialValue, if supplied.
 currentValue: The current element being processed in the array.
  index: The index of the current element being processed in the array.
   array: The array fold was called upon.
    initialValue: Object to use as the first argument to the first call of the callback. 

*/

function callbackImpl(previousValue, currentValue, i, array) {
    console.log("prev " + previousValue);
    console.log("curr " + currentValue);
    console.log("index " + i);
    console.log("array " + array.length);
    console.log("");
    return (currentValue + previousValue);
}


function processArray(array, callback, initialValue) {
    let currentValue;
    let previousValue = (initialValue != undefined) ? initialValue : "lol";
    for (let i = 0; i < array.length; i++) {
        currentValue = array[i];
        previousValue = callback(previousValue, currentValue, i, array);
    }
}

//processArray([0,1,2,3],callbackImpl,"");

/* Linear unfold 
    Implement linear unfold function that returns a sequence that contains the elements generated by the given computation:
    F(callback, initialValue) 
    callback: A function that takes the current state and returns a tuple consisting
    of the next element of the sequence and the next state value.
    Callback accepts current value and produces new state and element.
    Unfold stops upon falsy value returned by callback.
    initialValue: The initial state value.
*/

function callbackImpl2(state) {
    let random = currState * Math.floor(Math.random() * 5);
    let newState;
    if(random == 0)
        newState = null;

    let value = Math.floor(Math.random() * 100);
    return  {
        value: value,
        state:newState
    }
}


function UnfoldValue(callback, initialValue) {
    let values = [];
    let currState = initialValue;
    do {
        let callbackResult = callbackImpl2(currState);
        currState = callbackResult.state;
        values.push(callbackResult.value)
    } while (!currState)
    return values;
}

console.log("");